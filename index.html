<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2022-03-29 Tue 21:01 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>LisTeX</title>
<meta name="author" content="Alejandro Gallo" />
<meta name="generator" content="Org Mode" />
<style>
  #content { max-width: 60em; margin: auto; }
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #e6e6e6;
    border-radius: 3px;
    background-color: #f2f2f2;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
  }
  pre.src:before {
    display: none;
    position: absolute;
    top: -8px;
    right: 12px;
    padding: 3px;
    color: #555;
    background-color: #f2f2f299;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-authinfo::before { content: 'Authinfo'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
</style>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="content" class="content">
<h1 class="title">LisTeX</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org5d51527">1. Introduction</a>
<ul>
<li><a href="#orgffcade7">1.1. <span class="todo TODO">TODO</span> Philosophy</a></li>
<li><a href="#orgfdaabf5">1.2. What is to be done</a></li>
</ul>
</li>
<li><a href="#orgea96ff6">2. org-src blocks</a></li>
<li><a href="#org2955e67">3. Derived mode</a></li>
<li><a href="#orgf324f39">4. Misc</a></li>
<li><a href="#orga43d995">5. Types</a></li>
<li><a href="#org2ff8b43">6. Macros definition</a>
<ul>
<li><a href="#org7803ddd">6.1. Implementation</a></li>
<li><a href="#orgb3eb5ed">6.2. TeX macro definitions</a></li>
</ul>
</li>
<li><a href="#org1679de0">7. Render</a>
<ul>
<li><a href="#org47f089e">7.1. Implementation</a></li>
</ul>
</li>
<li><a href="#org8b73ea6">8. Macrolet</a></li>
<li><a href="#org5c55065">9. Tools</a>
<ul>
<li><a href="#orga404218">9.1. Preview listex</a></li>
</ul>
</li>
<li><a href="#orgbacd60e">10. Examples</a>
<ul>
<li><a href="#orgbcab1d7">10.1. Some equations</a>
<ul>
<li><a href="#org56c64bb">10.1.1. Newton</a></li>
<li><a href="#org439912f">10.1.2. Coupled cluster</a></li>
</ul>
</li>
<li><a href="#org41a938b">10.2. Latex document example</a></li>
<li><a href="#orgd0f3722">10.3. A matrix macro</a></li>
<li><a href="#orgd9d5533">10.4. Cmdlet</a></li>
<li><a href="#orgdc22e3b">10.5. Schwarzschild's paper</a></li>
<li><a href="#org155142e">10.6. XML renderer</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-org5d51527" class="outline-2">
<h2 id="org5d51527"><span class="section-number-2">1.</span> Introduction</h2>
<div class="outline-text-2" id="text-1">
<p>
This packages comes from the ocasional frustration of writing
latex in <code>org-mode</code> and having a sane default formating
of the equations. Also it comes from the lack of frustration
formating and writing s-expressions in Lisp.
Let's say, it originates in a "frustration transfer".
</p>

<p>
This package is written as a literate program cite:knuth.
If you want to contribute please consider writing in the style of the document.
</p>

<p>
You can see a rendered version of this document <a href="https://alejandrogallo.github.io/listex">here</a>.
</p>
</div>

<div id="outline-container-orgffcade7" class="outline-3">
<h3 id="orgffcade7"><span class="section-number-3">1.1.</span> <span class="todo TODO">TODO</span> Philosophy</h3>
<div class="outline-text-3" id="text-1-1">
<p>
This package should be as simple as possible while
providing good ergonomics (at least for me).
</p>

<p>
So, the main idea is that the user must provide
just a list that will be converted to a latex string
through the <code>listex</code> function.
</p>

<p>
This means, only a list is given and every component of the list
can be different kind of types recognized by the
<a href="#orga43d995">5</a> section.
</p>

<p>
This package has the following concepts:
</p>

<dl class="org-dl">
<dt><a href="#orga2da839">command</a></dt><dd>This should be the equivalent to latex commands, i.e.,
a latex symbol and some braces expressions denoting arguments,
for instance <code>\frac{A}{B}</code> rather than <code>\frac A B</code>.
In our DSL, this is denoted by a <code>-</code> prefix, i.e. this frac would be
<code>'(-frac A B)</code>. Be aware that listex has no sense of the
latex information for the <code>frac</code> command, i.e.
<code>'(-frac A B C D)</code> is allowed and gets rendered as
<code>\frac{A}{B}{C}{D}</code>.</dd>
<dt><a href="#orgcef850f">keyword</a></dt><dd>This is the counterpart to <a href="#orga2da839">command</a>, i.e. just latex keywords.
This can be at the beginning of the list of in the middle,
and gets introduced by the prefix <code>/</code>.
For instance,
<ul class="org-ul">
<li><code>'(/frac /alpha 2)</code> ⇒ <code>\frac \alpha 2</code></li>
<li><code>'(-frac /alpha 2)</code> ⇒ <code>\frac{\alpha}{2}</code></li>
</ul></dd>
<dt><a href="#org0ef70b6">operator</a></dt><dd>TODOCUMENT</dd>
<dt>lisp-macro</dt><dd>TODOCUMENT</dd>
<dt>tex-macro</dt><dd>TODOCUMENT</dd>
<dt>alias</dt><dd>TODOCUMENT</dd>
<dt>atom</dt><dd>TODOCUMENT</dd>
<dt>list</dt><dd>TODOCUMENT</dd>
</dl>



<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption class="t-above"><span class="table-number">Table 1:</span> Summary of the different types of commands existing in <code>listex</code></caption>

<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">name</th>
<th scope="col" class="org-left">prefix</th>
<th scope="col" class="org-left">Create</th>
<th scope="col" class="org-left">let construct</th>
<th scope="col" class="org-left">what</th>
<th scope="col" class="org-left">lisp</th>
<th scope="col" class="org-left">tex</th>
<th scope="col" class="org-left">Rule</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">command <a id="orga2da839"></a></td>
<td class="org-left"><code>-</code></td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">Latex commands</td>
<td class="org-left"><code>(-cmd a b c d)</code></td>
<td class="org-left"><code>\cmd{a}{b}{c}{d}</code></td>
<td class="org-left">by prefix</td>
</tr>

<tr>
<td class="org-left">keyword <a id="orgcef850f"></a></td>
<td class="org-left"><code>/</code></td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">Single keywords</td>
<td class="org-left"><code>(/cmd a b c d)</code></td>
<td class="org-left"><code>\cmd a b c d</code></td>
<td class="org-left">by prefix</td>
</tr>

<tr>
<td class="org-left">operator <a id="org0ef70b6"></a></td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">Infix inclusion</td>
<td class="org-left"><code>(+ a b c)</code></td>
<td class="org-left"><code>a + b + c</code></td>
<td class="org-left">is in <code>listex-operator-list</code></td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left"><code>%</code></td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left"><code>(%\\times A B)</code></td>
<td class="org-left"><code>A \times B</code></td>
<td class="org-left">by prefix</td>
</tr>

<tr>
<td class="org-left">lisp-macro</td>
<td class="org-left">&#xa0;</td>
<td class="org-left"><code>listex:defmacro</code></td>
<td class="org-left"><code>lt-macrolet</code></td>
<td class="org-left">Function returning a symbol or list</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">is in <code>listex-lisp-macro-alist</code></td>
</tr>

<tr>
<td class="org-left">tex-macro</td>
<td class="org-left">&#xa0;</td>
<td class="org-left"><code>listex:newcmd</code></td>
<td class="org-left"><code>lt-cmdlet</code></td>
<td class="org-left">Function returning a string</td>
<td class="org-left"><code>(^ a b)</code></td>
<td class="org-left"><code>a^{b}</code></td>
<td class="org-left">special case of <code>lisp-macro</code></td>
</tr>

<tr>
<td class="org-left">alias</td>
<td class="org-left">&#xa0;</td>
<td class="org-left"><code>listex:defalias</code></td>
<td class="org-left"><code>lt-aliaslet</code></td>
<td class="org-left">Simple symbol replacement</td>
<td class="org-left"><code>λ</code></td>
<td class="org-left"><code>\lambda</code></td>
<td class="org-left">is in <code>listex-alias-alist</code></td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">atom</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">Convert whatever to string</td>
<td class="org-left"><code>int</code></td>
<td class="org-left"><code>int</code></td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left"><code>[a=5, b]</code></td>
<td class="org-left"><code>[a=5, b]</code></td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left"><code>"a ()\sum"</code></td>
<td class="org-left"><code>a ()\sum</code></td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">list</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">Join elements by space</td>
<td class="org-left"><code>(a b)</code></td>
<td class="org-left"><code>a b</code></td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
</table>
</div>
</div>




<div id="outline-container-orgfdaabf5" class="outline-3">
<h3 id="orgfdaabf5"><span class="section-number-3">1.2.</span> What is to be done</h3>
<div class="outline-text-3" id="text-1-2">
<ul class="org-ul">
<li>Some real world testing
<ul class="org-ul">
<li>to find bugs</li>
<li>to finalize the DSL, right now I think it's quite
ergonomic, but it might be wrong.</li>
</ul></li>
<li>Think about which rules to implement for the latex indentation.</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-orgea96ff6" class="outline-2">
<h2 id="orgea96ff6"><span class="section-number-2">2.</span> org-src blocks</h2>
<div class="outline-text-2" id="text-2">
<p>
In org mode we want to have easily accessible code blocks like
</p>

<div class="org-src-container">
<pre class="src src-org"><span style="font-weight: bold; font-style: italic;">#+begin_src listex :env al* :label dr-dv</span>
(let ((d '(-mathrm d)))
  `(-frac (,d r)
          (,d v)))
<span style="font-weight: bold; font-style: italic;">#+end_src</span>

<span style="font-weight: bold; font-style: italic;">#+RESULTS:</span>
<span style="font-weight: bold;">:results:</span>
\begin{align*}
\label{dr-dv} \frac{\mathrm{d} r}{\mathrm{d} v}
\end{align*}
<span style="font-weight: bold;">:end:</span>
</pre>
</div>


<p>
We have beyond the usual flags, the following:
</p>

<dl class="org-dl">
<dt>:label</dt><dd>This is the latex label that should be used included
in the expression automatically.
Also a local lisp variable will be created with the same
name so that one can reuse the expression somewhere else.</dd>
<dt>:lisp-label</dt><dd>Sometime we want to reuse the expression
but we do not want a tex label, so <code>:lisp-label</code>
sets the lisp variable to the expression as in <code>:label</code>
but then no tex label is necessary.</dd>
<dt>:env</dt><dd>It is possible to wrap the expression in an environment
before the expression gets rendered to latex.
Possible values are for instance <code>$, $$, eq, eq*, al, al*</code>
etc.</dd>
</dl>



<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="font-weight: bold;">defvar</span> <span style="font-weight: bold; font-style: italic;">org-babel-default-header-args:listex</span> '((<span style="font-weight: bold;">:exports</span> . <span style="font-style: italic;">"results"</span>)
                                               (<span style="font-weight: bold;">:results</span> . <span style="font-style: italic;">"value drawer"</span>)
                                               (<span style="font-weight: bold;">:eval</span> . <span style="font-style: italic;">"t"</span>)))

(<span style="font-weight: bold;">defvar</span> <span style="font-weight: bold; font-style: italic;">org-babel-header-args:listex</span> '((<span style="font-weight: bold;">:label</span> . <span style="font-weight: bold;">:any</span>)
                                       (<span style="font-weight: bold;">:lisp-label</span> . <span style="font-weight: bold;">:any</span>)
                                       (<span style="font-weight: bold;">:env</span> . <span style="font-weight: bold;">:any</span>)
                                       (<span style="font-weight: bold;">:eval</span> . <span style="font-weight: bold;">:boolean</span>))
  <span style="font-style: italic;">"listex-specific header arguments."</span>)

(<span style="font-weight: bold;">defun</span> <span style="font-weight: bold;">org-babel-execute:listex</span> (body params)
  (<span style="font-weight: bold;">cl-labels</span> ((maybe-symbol (key) (<span style="font-weight: bold;">let</span> ((maybe-string (cdr (assq key params))))
                                    (<span style="font-weight: bold;">when</span> maybe-string (intern maybe-string)))))
    (<span style="font-weight: bold;">let*</span> ((should-eval (maybe-symbol <span style="font-weight: bold;">:eval</span>))
           (raw-expr (car (read-from-string body)))
           (expr (<span style="font-weight: bold;">if</span> should-eval (eval raw-expr) raw-expr))
           (env (maybe-symbol <span style="font-weight: bold;">:env</span>))
           (label (maybe-symbol <span style="font-weight: bold;">:label</span>))
           (lisp-label (<span style="font-weight: bold;">or</span> (maybe-symbol <span style="font-weight: bold;">:lisp-label</span>)
                           label)))
      (message <span style="font-style: italic;">"penis %s %s"</span> should-eval (type-of should-eval))
      (<span style="font-weight: bold;">when</span> lisp-label
        (message <span style="font-style: italic;">"new lisp-label defined: %s"</span> lisp-label)
        (eval `(<span style="font-weight: bold;">setq-local</span> ,lisp-label ',expr)))
      (listex
       (<span style="font-weight: bold;">if</span> env
           `(,env ,(<span style="font-weight: bold;">if</span> label
                       `((-label ,label) ,expr)
                     expr))
         expr)))))
</pre>
</div>
</div>
</div>

<div id="outline-container-org2955e67" class="outline-2">
<h2 id="org2955e67"><span class="section-number-2">3.</span> Derived mode</h2>
<div class="outline-text-2" id="text-3">
<p>
We define a derived mode based on the <code>emacs-lisp</code> mode
to make it easy to edit the s-expressions with your preferred bindings.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="font-weight: bold;">define-derived-mode</span> <span style="font-weight: bold;">listex-mode</span>
  emacs-lisp-mode <span style="font-style: italic;">"LiSTeX"</span>
  <span style="font-style: italic;">"Major mode for listex.</span>
<span style="font-style: italic;">\\{listex-mode-map}"</span>)
</pre>
</div>
</div>
</div>

<div id="outline-container-orgf324f39" class="outline-2">
<h2 id="orgf324f39"><span class="section-number-2">4.</span> Misc</h2>
<div class="outline-text-2" id="text-4">
<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="font-weight: bold;">defvar</span> <span style="font-weight: bold; font-style: italic;">listex-keyword-prefix</span> <span style="font-style: italic;">"/"</span>)
(<span style="font-weight: bold;">defvar</span> <span style="font-weight: bold; font-style: italic;">listex-command-prefix</span> <span style="font-style: italic;">"-"</span>)

(<span style="font-weight: bold;">defvar</span> <span style="font-weight: bold; font-style: italic;">listex-operator-prefix</span> <span style="font-style: italic;">"%"</span>)
(<span style="font-weight: bold;">defvar</span> <span style="font-weight: bold; font-style: italic;">listex-operator-list</span> '(+ * - =))

(<span style="font-weight: bold;">defun</span> <span style="font-weight: bold;">listex:indentation</span> (len)
  (eval `(concat ,@(<span style="font-weight: bold;">cl-loop</span> for i from 1 to len collect <span style="font-style: italic;">" "</span>))))
</pre>
</div>
</div>
</div>

<div id="outline-container-orga43d995" class="outline-2">
<h2 id="orga43d995"><span class="section-number-2">5.</span> Types</h2>
<div class="outline-text-2" id="text-5">
<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="font-weight: bold;">cl-deftype</span> <span style="font-weight: bold; text-decoration: underline;">listex:keyword</span> ()
  '(<span style="font-weight: bold;">and</span> symbol
        (satisfies (<span style="font-weight: bold;">lambda</span> (k)
                     (string-prefix-p listex-keyword-prefix
                                      (format <span style="font-style: italic;">"%s"</span> k))))))

(<span style="font-weight: bold;">cl-deftype</span> <span style="font-weight: bold; text-decoration: underline;">listex:car-is-atom</span> ()
  '(satisfies (<span style="font-weight: bold;">lambda</span> (expr) (atom (car expr)))))

(<span style="font-weight: bold;">cl-deftype</span> <span style="font-weight: bold; text-decoration: underline;">listex:command</span> ()
  '(<span style="font-weight: bold;">and</span> list
        listex:car-is-atom
        (satisfies (<span style="font-weight: bold;">lambda</span> (expr)
                     (<span style="font-weight: bold;">let</span> ((name (format <span style="font-style: italic;">"%s"</span> (car expr))))
                       (string-prefix-p listex-command-prefix
                                        name))))))

(<span style="font-weight: bold;">cl-deftype</span> <span style="font-weight: bold; text-decoration: underline;">listex:operator</span> ()
  '(<span style="font-weight: bold;">and</span> list
        listex:car-is-atom
        (satisfies (<span style="font-weight: bold;">lambda</span> (expr)
                     (<span style="font-weight: bold;">let</span> ((name (car expr)))
                       (<span style="font-weight: bold;">or</span> (member name listex-operator-list)
                           (string-prefix-p listex-operator-prefix
                                            (format <span style="font-style: italic;">"%s"</span> name))))))))


(<span style="font-weight: bold;">defmacro</span> <span style="font-weight: bold;">listex:lisp-macro-get-fun</span> (name)
  `(alist-get ,name listex-lisp-macro-alist))

(<span style="font-weight: bold;">cl-deftype</span> <span style="font-weight: bold; text-decoration: underline;">listex:lisp-macro</span> ()
  '(<span style="font-weight: bold;">and</span> list
        listex:car-is-atom
        (satisfies (<span style="font-weight: bold;">lambda</span> (expr) (listex:lisp-macro-get-fun (car expr))))))

(<span style="font-weight: bold;">defvar</span> <span style="font-weight: bold; font-style: italic;">listex-alias-alist</span> nil
  <span style="font-style: italic;">"Alist holding all the aliases."</span>)

(<span style="font-weight: bold;">defmacro</span> <span style="font-weight: bold;">listex:get-alias</span> (name)
  `(alist-get ,name listex-alias-alist))

(<span style="font-weight: bold;">cl-deftype</span> <span style="font-weight: bold; text-decoration: underline;">listex:alias</span> ()
  '(<span style="font-weight: bold;">and</span> symbol
        (satisfies (<span style="font-weight: bold;">lambda</span> (expr) (listex:get-alias expr)))))
</pre>
</div>
</div>
</div>

<div id="outline-container-org2ff8b43" class="outline-2">
<h2 id="org2ff8b43"><span class="section-number-2">6.</span> Macros definition</h2>
<div class="outline-text-2" id="text-6">
</div>
<div id="outline-container-org7803ddd" class="outline-3">
<h3 id="org7803ddd"><span class="section-number-3">6.1.</span> Implementation</h3>
<div class="outline-text-3" id="text-6-1">
<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="font-weight: bold;">defvar</span> <span style="font-weight: bold; font-style: italic;">listex-lisp-macro-alist</span> nil
  <span style="font-style: italic;">"Alist storing all listex macros that are defined."</span>)

(<span style="font-weight: bold;">defmacro</span> <span style="font-weight: bold;">listex:lisp-macro-alist-pair</span> (alist key args list-or-fun)
  `(list '(alist-get ',key ,alist)
         ,(<span style="font-weight: bold;">cl-etypecase</span> list-or-fun
            (<span style="font-weight: bold;">function</span> list-or-fun)
            (list `(<span style="font-weight: bold;">cl-flet</span> ((f ,args ,list-or-fun))
                     (<span style="font-weight: bold;">cl-function</span> f))))))

(<span style="font-weight: bold;">defmacro</span> <span style="font-weight: bold;">listex:defmacro</span> (key !args list-or-fun)
  `(<span style="font-weight: bold;">let</span> ((args (listex:lisp-macro-alist-pair listex-lisp-macro-alist
                                             ,key
                                             ,!args
                                             ,list-or-fun)))
     (eval `(<span style="font-weight: bold;">setf</span> ,@args))))



(<span style="font-weight: bold;">defmacro</span> <span style="font-weight: bold;">listex:newcmd--format-function</span> (args fmt)
  `(format ,fmt ,@(<span style="font-weight: bold;">cl-loop</span> for a in args
                           <span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">make sure that a is not a &amp; identifier</span>
                           <span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">for functions like &amp;rest</span>
                           if (not (string-prefix-p <span style="font-style: italic;">"&amp;"</span> (symbol-name a)))
                           collect `(listex:render-tex ,a))))

(<span style="font-weight: bold;">defmacro</span> <span style="font-weight: bold;">listex:newcmd</span> (key args fmt)
  `(listex:defmacro ,key ,args (listex:newcmd--format-function ,args, fmt)))
</pre>
</div>

<p>
and for the aliases we define <code>defalias</code>
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="font-weight: bold;">defmacro</span> <span style="font-weight: bold;">listex:defalias</span> (alias key)
  `(<span style="font-weight: bold;">setf</span> (alist-get ',alias listex-alias-alist) ',key))
</pre>
</div>
</div>
</div>


<div id="outline-container-orgb3eb5ed" class="outline-3">
<h3 id="orgb3eb5ed"><span class="section-number-3">6.2.</span> TeX macro definitions</h3>
<div class="outline-text-3" id="text-6-2">
<p>
This package defines some macros by default for use in the src code and
for ease of use for others.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp"><span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">important macros</span>
(listex:newcmd braced (<span style="font-weight: bold; text-decoration: underline;">&amp;rest</span> body) <span style="font-style: italic;">"{%s}"</span>)
(listex:newcmd progn (<span style="font-weight: bold; text-decoration: underline;">&amp;rest</span> body) <span style="font-style: italic;">"%s"</span>)
(listex:newcmd list (<span style="font-weight: bold; text-decoration: underline;">&amp;rest</span> body) <span style="font-style: italic;">"%s"</span>)

<span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">left right stuff</span>
(listex:newcmd lr (l r <span style="font-weight: bold; text-decoration: underline;">&amp;rest</span> body) <span style="font-style: italic;">"\\left%1$s %3$s \\right%2$s"</span>)
(listex:defmacro lrp (<span style="font-weight: bold; text-decoration: underline;">&amp;rest</span> args) `(lr \( \) ,@args))
(listex:defmacro lrs (<span style="font-weight: bold; text-decoration: underline;">&amp;rest</span> args) `(lr \[ \] ,@args))
(listex:defmacro set (<span style="font-weight: bold; text-decoration: underline;">&amp;rest</span> args) `(lr /{ /} ,@args))

<span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">quantum mechanics</span>
(listex:defmacro &lt;| (<span style="font-weight: bold; text-decoration: underline;">&amp;rest</span> args) `(lr /langle | ,@args))
(listex:defmacro |&gt; (<span style="font-weight: bold; text-decoration: underline;">&amp;rest</span> args) `(lr | /rangle ,@args))

<span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">exponents</span>
(listex:newcmd ^ (base <span style="font-weight: bold; text-decoration: underline;">&amp;rest</span> sup) <span style="font-style: italic;">"%s^{%s}"</span>)
(listex:newcmd _ (base <span style="font-weight: bold; text-decoration: underline;">&amp;rest</span> sub) <span style="font-style: italic;">"%s_{%s}"</span>)
(listex:newcmd ^_ (base sup sub) <span style="font-style: italic;">"%s^{%s}_{%s}"</span>)
(listex:newcmd _^ (base sub sup) <span style="font-style: italic;">"%s_{%s}^{%s}"</span>)

<span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">wrapping</span>
(listex:newcmd begend (b <span style="font-weight: bold; text-decoration: underline;">&amp;rest</span> bod) <span style="font-style: italic;">"%s%s%1$s"</span>)
(listex:newcmd env (env-name <span style="font-weight: bold; text-decoration: underline;">&amp;rest</span> body) <span style="font-style: italic;">"\\begin{%1$s}\n%s\n\\end{%1$s}"</span>)

(listex:defmacro mat (<span style="font-weight: bold; text-decoration: underline;">&amp;rest</span> args) `(env pmatrix ,@args))

<span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">Math environments</span>
(listex:defmacro $ (<span style="font-weight: bold; text-decoration: underline;">&amp;rest</span> args) `(begend $ ,@args))
(listex:defmacro $$ (<span style="font-weight: bold; text-decoration: underline;">&amp;rest</span> args) `(begend $$ ,@args))
(listex:defmacro eq (<span style="font-weight: bold; text-decoration: underline;">&amp;rest</span> args) `(env equation ,@args))
(listex:defmacro eq* (<span style="font-weight: bold; text-decoration: underline;">&amp;rest</span> args) `(env equation* ,@args))
(listex:defmacro al (<span style="font-weight: bold; text-decoration: underline;">&amp;rest</span> args) `(env align ,@args))
(listex:defmacro al* (<span style="font-weight: bold; text-decoration: underline;">&amp;rest</span> args) `(env align* ,@args))

<span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">force newlines in the output</span>
(listex:newcmd terpri () <span style="font-style: italic;">"\n"</span>)
(listex:newcmd br () <span style="font-style: italic;">"\n"</span>)
(listex:newcmd nl () <span style="font-style: italic;">"\n"</span>)

<span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">more convoluted example</span>
(listex:defmacro matrix
                 (rows cols <span style="font-weight: bold; text-decoration: underline;">&amp;rest</span> elements)
                 (<span style="font-weight: bold;">progn</span>
                   (<span style="font-weight: bold;">cl-assert</span> (eq (length elements) (* cols rows)))
                   `(env pmatrix
                         ,@(<span style="font-weight: bold;">cl-loop</span> for el in elements
                                    with i = 0
                                    with buff = nil
                                    do (<span style="font-weight: bold;">push</span> el buff)
                                    do (<span style="font-weight: bold;">cl-incf</span> i)
                                    if (eq (% i cols) 0)
                                    do (<span style="font-weight: bold;">push</span> '\\\\ buff)
                                    and collect (reverse buff)
                                    and do (<span style="font-weight: bold;">setf</span> buff nil)
                                    else
                                    do (<span style="font-weight: bold;">push</span> '&amp; buff)))))
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org1679de0" class="outline-2">
<h2 id="org1679de0"><span class="section-number-2">7.</span> Render</h2>
<div class="outline-text-2" id="text-7">
</div>
<div id="outline-container-org47f089e" class="outline-3">
<h3 id="org47f089e"><span class="section-number-3">7.1.</span> Implementation</h3>
<div class="outline-text-3" id="text-7-1">
<div class="org-src-container">
<pre class="src src-emacs-lisp">
(<span style="font-weight: bold;">defun</span> <span style="font-weight: bold;">listex:render-tex</span> (expr)
  <span style="font-style: italic;">"Main function to convert a listex DSL s-expression</span>
<span style="font-style: italic;">   into a latex-compatible string."</span>
  (<span style="font-weight: bold;">cl-etypecase</span> expr
    (listex:lisp-macro (<span style="font-weight: bold;">let*</span> ((args (cdr expr))
                              (name (car expr))
                              (f (listex:lisp-macro-get-fun name))
                              (new-expr (apply f args)))
                         (listex:render-tex new-expr)))
    (listex:alias (<span style="font-weight: bold;">let*</span> ((replacement (listex:get-alias expr)))
                    (listex:render-tex replacement)))
    (listex:keyword (format <span style="font-style: italic;">"\\%s"</span>
                            (string-remove-prefix listex-keyword-prefix
                                                  (symbol-name expr))))
    (listex:command
     (<span style="font-weight: bold;">let*</span> ((args (mapcar (<span style="font-weight: bold;">lambda</span> (e) (<span style="font-weight: bold;">cl-etypecase</span> e
                                        (vector e)
                                        (otherwise (format
                                                    <span style="font-style: italic;">"{%s}"</span>
                                                    (listex:render-tex e)))))
                          (cdr expr)))
            (name (format <span style="font-style: italic;">"\\%s"</span> (string-remove-prefix listex-command-prefix
                                                       (symbol-name
                                                        (car expr)))))
            (args-strings (mapcar #'listex:render-tex args)))
       (concat name (string-join args-strings))))
    (listex:operator (<span style="font-weight: bold;">let*</span> ((name (car expr))
                            (namestr (symbol-name name))
                            (op (<span style="font-weight: bold;">if</span> (&gt; (length namestr) 1)
                                    (string-remove-prefix listex-operator-prefix
                                                          namestr)
                                  namestr)))
                       (string-join (mapcar #'listex:render-tex (cdr expr))
                                    (format <span style="font-style: italic;">" %s "</span> op))))
    (list (string-join (mapcar #'listex:render-tex expr) <span style="font-style: italic;">" "</span>))
    (atom (format <span style="font-style: italic;">"%s"</span> expr))))




(<span style="font-weight: bold;">defun</span> <span style="font-weight: bold;">listex</span> (expr)
  (listex:render-tex expr))
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org8b73ea6" class="outline-2">
<h2 id="org8b73ea6"><span class="section-number-2">8.</span> Macrolet</h2>
<div class="outline-text-2" id="text-8">
<p>
In order to have a macrolet-like behaviour we need
to have an expander of our lisp-like macros, i.e.
of expressions of the type <code>listex:lisp-macro</code>
that are defined by the <code>listex:defmacro</code> macro.
</p>

<p>
However, since a lexical scope environment will be destroyed
after the scope, we need to expand the forms inside the
equation by the macros that have been defined.
Thankfully this is not very difficult and is done
in the <code>listex:expand-lisp-macro</code> function.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="font-weight: bold;">cl-defun</span> <span style="font-weight: bold;">listex:expand-lisp-macro</span> (expr <span style="font-weight: bold; text-decoration: underline;">&amp;key</span> recursive)
  <span style="font-style: italic;">"This function should expand all listex:lisp-macro</span>
<span style="font-style: italic;">   s-expressions by the s-expression that they expand to,</span>
<span style="font-style: italic;">   so that in some cases you can just get the whole.</span>

<span style="font-style: italic;">   This works as it follows:</span>

<span style="font-style: italic;">   - if an expression is a lisp-macro,</span>
<span style="font-style: italic;">     then it will first expand its arguments</span>
<span style="font-style: italic;">     and then return the expansion of the parent</span>
<span style="font-style: italic;">     with the expansion of the arguments replaced.</span>
<span style="font-style: italic;">   - If an expression is a command, tex-macro</span>
<span style="font-style: italic;">     or an operator expression, then it will replace</span>
<span style="font-style: italic;">     the same expression just with the elements replaced</span>
<span style="font-style: italic;">     by their expansions.</span>
<span style="font-style: italic;">   - Otherwise, it should replace just the bare expression."</span>
  (<span style="font-weight: bold;">cl-flet</span> ((expander (e) (listex:expand-lisp-macro e <span style="font-weight: bold;">:recursive</span> recursive)))
    (<span style="font-weight: bold;">cl-typecase</span> expr
      (listex:lisp-macro (<span style="font-weight: bold;">let*</span> ((name (car expr))
                                (args (mapcar #'expander (cdr expr)))
                                (f (listex:lisp-macro-get-fun name))
                                (new-expr (apply f args)))
                           (<span style="font-weight: bold;">if</span> recursive (expander new-expr) new-expr)))
      (listex:alias (<span style="font-weight: bold;">let</span> ((new-expr (listex:get-alias expr)))
                      (<span style="font-weight: bold;">if</span> recursive (expander new-expr) new-expr)))
      <span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">expand the arguments</span>
      ((<span style="font-weight: bold;">or</span> listex:command listex:operator)
       (<span style="font-weight: bold;">let</span> ((name (car expr))
             (args (mapcar #'expander (cdr expr))))
         `(,name ,@args)))
      (list (mapcar #'expander expr))
      (otherwise expr))))
</pre>
</div>

<p>
The <code>lt-macrolet</code> will expand the macros defined in the
let body using <code>listex:expand-lisp-macro</code> so that they
are portable outside of this environment and you do not need
to define globally the macros and pollute the listex
macro environment.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="font-weight: bold;">defmacro</span> <span style="font-weight: bold;">listex:letconstruct</span> (recursive
                               pair-constructor
                               alist bindings
                               <span style="font-weight: bold; text-decoration: underline;">&amp;rest</span> body)
  (<span style="font-weight: bold;">let</span> ((letf-args (<span style="font-weight: bold;">cl-loop</span> for b in bindings
                            collect (eval `(,pair-constructor
                                            ,alist
                                            ,@b)))))
    `(<span style="font-weight: bold;">cl-letf</span> (,@letf-args)
       (listex:expand-lisp-macro (<span style="font-weight: bold;">progn</span> ,@body) <span style="font-weight: bold;">:recursive</span> ,recursive))))

(<span style="font-weight: bold;">defmacro</span> <span style="font-weight: bold;">listex:alias-alist-pair</span> (alist key replacement)
  `(list '(alist-get ',key ,alist)
     ,(<span style="font-weight: bold;">cl-etypecase</span> replacement
        ((<span style="font-weight: bold;">or</span> atom cons) `',replacement))))

(<span style="font-weight: bold;">defmacro</span> <span style="font-weight: bold;">lt-aliaslet</span> (bindings <span style="font-weight: bold; text-decoration: underline;">&amp;rest</span> body)
  `(listex:letconstruct nil
                        listex:alias-alist-pair
                        listex-alias-alist
                        ,bindings
                        ,@body))

(<span style="font-weight: bold;">defmacro</span> <span style="font-weight: bold;">lt-aliaslet*</span> (bindings <span style="font-weight: bold; text-decoration: underline;">&amp;rest</span> body)
  `(listex:letconstruct t
                        listex:alias-alist-pair
                        listex-alias-alist
                        ,bindings
                        ,@body))

(<span style="font-weight: bold;">defmacro</span> <span style="font-weight: bold;">lt-macrolet</span> (bindings <span style="font-weight: bold; text-decoration: underline;">&amp;rest</span> body)
  `(listex:letconstruct nil
                        listex:lisp-macro-alist-pair
                        listex-lisp-macro-alist
                        ,bindings
                        ,@body))

(<span style="font-weight: bold;">defmacro</span> <span style="font-weight: bold;">lt-macrolet*</span> (bindings <span style="font-weight: bold; text-decoration: underline;">&amp;rest</span> body)
  `(listex:letconstruct t
                        listex:lisp-macro-alist-pair
                        listex-lisp-macro-alist
                        ,bindings
                        ,@body))

(<span style="font-weight: bold;">defmacro</span> <span style="font-weight: bold;">lt-cmdlet</span> (cmds <span style="font-weight: bold; text-decoration: underline;">&amp;rest</span> body)
  `(lt-macrolet ,(<span style="font-weight: bold;">cl-loop</span> for cmd in cmds
                          collect
                          (<span style="font-weight: bold;">let</span> ((key (car cmd))
                                (args (cadr cmd))
                                (fmt (caddr cmd)))
                            `(,key ,args
                                   (listex:newcmd--format-function ,args
                                                                   ,fmt))))
     ,@body))

<span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">set indentation for lt-macrolet and other let constructs correctly</span>
(<span style="font-weight: bold;">progn</span>
  (put 'lt-aliaslet 'lisp-indent-function 'defun)
  (put 'lt-aliaslet* 'lisp-indent-function 'defun)
  (put 'lt-macrolet 'lisp-indent-function 'defun)
  (put 'lt-macrolet* 'lisp-indent-function 'defun)
  (put 'lt-cmdlet 'lisp-indent-function 'defun))
</pre>
</div>
</div>
</div>


<div id="outline-container-org5c55065" class="outline-2">
<h2 id="org5c55065"><span class="section-number-2">9.</span> Tools</h2>
<div class="outline-text-2" id="text-9">
</div>
<div id="outline-container-orga404218" class="outline-3">
<h3 id="orga404218"><span class="section-number-3">9.1.</span> Preview listex</h3>
<div class="outline-text-3" id="text-9-1">
<p>
A tool for previewing the latex created might be very useful
when working in src-blocks
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="font-weight: bold;">defun</span> <span style="font-weight: bold;">listex:render-last-sexpr</span> (<span style="font-weight: bold; text-decoration: underline;">&amp;optional</span> not-eval?)
  (<span style="font-weight: bold;">interactive</span> <span style="font-style: italic;">"P"</span>)
  (<span style="font-weight: bold;">let</span> ((sexp (thing-at-point 'sexp)))
    (message (listex:render-tex (<span style="font-weight: bold;">if</span> not-eval?
                                    (read sexp)
                                    (eval (read sexp)))))))

(<span style="font-weight: bold;">defun</span> <span style="font-weight: bold;">listex:render-defun</span> (<span style="font-weight: bold; text-decoration: underline;">&amp;optional</span> not-eval?)
  (<span style="font-weight: bold;">interactive</span> <span style="font-style: italic;">"P"</span>)
  (<span style="font-weight: bold;">let</span> ((sexp (thing-at-point 'defun)))
    (message (listex:render-tex (<span style="font-weight: bold;">if</span> not-eval?
                                    (read sexp)
                                    (eval (read sexp)))))))
</pre>
</div>

<p>
you can use these by doing
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="font-weight: bold;">use-package</span> <span style="font-weight: bold; text-decoration: underline;">listex</span>
    <span style="font-weight: bold;">:config</span>
    (evil-define-key '(insert normal) listex-mode-map
      (kbd <span style="font-style: italic;">"C-c C-c"</span>) #'listex:render-defun
      (kbd <span style="font-style: italic;">"C-c C-e"</span>) #'listex:render-last-sexpr))
</pre>
</div>

<p>
if you are using <code>evil</code> mode for instance.
</p>
</div>
</div>
</div>

<div id="outline-container-orgbacd60e" class="outline-2">
<h2 id="orgbacd60e"><span class="section-number-2">10.</span> Examples</h2>
<div class="outline-text-2" id="text-10">
</div>

<div id="outline-container-orgbcab1d7" class="outline-3">
<h3 id="orgbcab1d7"><span class="section-number-3">10.1.</span> Some equations</h3>
<div class="outline-text-3" id="text-10-1">
</div>
<div id="outline-container-org56c64bb" class="outline-4">
<h4 id="org56c64bb"><span class="section-number-4">10.1.1.</span> Newton</h4>
<div class="outline-text-4" id="text-10-1-1">
<p>
A simple equation will be
</p>

<div class="org-src-container">
<pre class="src src-listex">'(= (-mathbf F)
    (m (-mathbf v)))
</pre>
</div>

<p>
\[\mathbf{F} = m \mathbf{v}\]
</p>

<p>
but of course you have all the power of <code>emacs-lisp</code> at your disposal,
so you can get a little more creative with how you organize
things:
</p>

<div class="org-src-container">
<pre class="src src-listex">(let ((d '(-mathrm d))
      (F '(-mathbf F))
      (v '(-mathbf v))
      (p '(-mathbf p))
      (X '%\\times))
  (cl-labels ((D (e x) `(-frac (,d ,e) (,d ,x))))
    `(= ,F
	,(D p 't)
	(+ (,X ,(D 'm 't)
	       ,v)
	   (,X m
	       ,(D v 't)))
	)))
</pre>
</div>

\begin{equation}
\mathbf{F} = \frac{\mathrm{d} \mathbf{p}}{\mathrm{d} t} = \frac{\mathrm{d} m}{\mathrm{d} t} \times \mathbf{v} + m \times \frac{\mathrm{d} \mathbf{v}}{\mathrm{d} t}
\end{equation}

<p>
Up to now, everything has been using regular macros from <code>elisp</code>.
Listex presents some convenience macros implementing similar lexical scopes
for latex macros and symbol aliases, for instance
</p>

<p>
&lt;newton-macroletted&gt;=
</p>
<div class="org-src-container">
<pre class="src src-listex">(lt-macrolet ((Dt (f) `(-frac ((-mathrm d) ,f)
			      ((-mathrm d) t)))
	      (bf (n) `(-mathbf ,n)))
  (lt-aliaslet ((*p* '(bf p))
		(*v* '(bf v))
		(*F* '(bf F))
		(⨉ '%\\times))
    '(= *F*
	(Dt *p*)
	(+ (⨉ (Dt m) *v*)
	   (⨉ m (Dt *v*))))))
</pre>
</div>

<p>
\[\mathbf{F} = \frac{\mathrm{d} \mathbf{p}}{\mathrm{d} t} = \frac{\mathrm{d} m}{\mathrm{d} t} \times \mathbf{v} + m \times \frac{\mathrm{d} \mathbf{v}}{\mathrm{d} t}\]
</p>

<p>
This last expression expands to
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">'(= (-mathbf F)
    (-frac ((-mathrm d) (-mathbf p)) ((-mathrm d) t))
    (+ (%\times (-frac ((-mathrm d) m) ((-mathrm d) t))
                (-mathbf v))
       (%\times m
                (-frac ((-mathrm d) (-mathbf v)) ((-mathrm d) t)))))
</pre>
</div>
</div>
</div>

<div id="outline-container-org439912f" class="outline-4">
<h4 id="org439912f"><span class="section-number-4">10.1.2.</span> Coupled cluster</h4>
<div class="outline-text-4" id="text-10-1-2">
<p>
This example writes the cluster operator in coupled cluster theory
as an example for managing align environments.
</p>

<div class="org-src-container">
<pre class="src src-listex">(cl-labels (;; mathematics and second quantization
	    (Σ (idx) `(_ (/sum /limits) ,idx))
	    (t (up down) `(_ (^ t ,up) ,down))
	    (a (i) `(_ (-hat a) ,i))
	    (á (i) `(^ ,(a i) /dagger))
	    (áa (up down) `(,(mapcar #'á up)
			    ,(mapcar #'a (reverse down))))

	    ;; define particles and holes
	    (parts (n) (seq-take '(a b c d e f g A B C D E F G) n))
	    (holes (n) (seq-take '(i j k l m n o I J K L M N O) n))

	    ;; Coupled cluster term of order n
	    (term (n) (let ((pow (progn (require 'calc-bin) (math-power-of-2 n)))
			    (abc (parts n))
			    (ijk (holes n)))
			(list (when (&gt; n 1) (list '-frac 1 pow))
			      (Σ `(,@abc ,@ijk))
			      (t abc ijk)
			      (áa abc ijk)))))
  ;; this inserts a plus and &amp; and \\ for the align environment
  (let ((+ '%\\\\&amp;+))

    `(%&amp;= (-hat T)
	  (,+ ,@(cl-loop for i from 1 to 10 collect (term i))
	      /cdots))))
</pre>
</div>

\begin{align*}
\hat{T} &=  \sum \limits_{a i} t^{a}_{i} \hat{a}_{a}^{\dagger} \hat{a}_{i} \\&+ \frac{1}{4} \sum \limits_{a b i j} t^{a b}_{i j} \hat{a}_{a}^{\dagger} \hat{a}_{b}^{\dagger} \hat{a}_{j} \hat{a}_{i} \\&+ \frac{1}{8} \sum \limits_{a b c i j k} t^{a b c}_{i j k} \hat{a}_{a}^{\dagger} \hat{a}_{b}^{\dagger} \hat{a}_{c}^{\dagger} \hat{a}_{k} \hat{a}_{j} \hat{a}_{i} \\&+ \frac{1}{16} \sum \limits_{a b c d i j k l} t^{a b c d}_{i j k l} \hat{a}_{a}^{\dagger} \hat{a}_{b}^{\dagger} \hat{a}_{c}^{\dagger} \hat{a}_{d}^{\dagger} \hat{a}_{l} \hat{a}_{k} \hat{a}_{j} \hat{a}_{i} \\&+ \frac{1}{32} \sum \limits_{a b c d e i j k l m} t^{a b c d e}_{i j k l m} \hat{a}_{a}^{\dagger} \hat{a}_{b}^{\dagger} \hat{a}_{c}^{\dagger} \hat{a}_{d}^{\dagger} \hat{a}_{e}^{\dagger} \hat{a}_{m} \hat{a}_{l} \hat{a}_{k} \hat{a}_{j} \hat{a}_{i} \\&+ \frac{1}{64} \sum \limits_{a b c d e f i j k l m n} t^{a b c d e f}_{i j k l m n} \hat{a}_{a}^{\dagger} \hat{a}_{b}^{\dagger} \hat{a}_{c}^{\dagger} \hat{a}_{d}^{\dagger} \hat{a}_{e}^{\dagger} \hat{a}_{f}^{\dagger} \hat{a}_{n} \hat{a}_{m} \hat{a}_{l} \hat{a}_{k} \hat{a}_{j} \hat{a}_{i} \\&+ \frac{1}{128} \sum \limits_{a b c d e f g i j k l m n o} t^{a b c d e f g}_{i j k l m n o} \hat{a}_{a}^{\dagger} \hat{a}_{b}^{\dagger} \hat{a}_{c}^{\dagger} \hat{a}_{d}^{\dagger} \hat{a}_{e}^{\dagger} \hat{a}_{f}^{\dagger} \hat{a}_{g}^{\dagger} \hat{a}_{o} \hat{a}_{n} \hat{a}_{m} \hat{a}_{l} \hat{a}_{k} \hat{a}_{j} \hat{a}_{i} \\&+ \frac{1}{256} \sum \limits_{a b c d e f g A i j k l m n o I} t^{a b c d e f g A}_{i j k l m n o I} \hat{a}_{a}^{\dagger} \hat{a}_{b}^{\dagger} \hat{a}_{c}^{\dagger} \hat{a}_{d}^{\dagger} \hat{a}_{e}^{\dagger} \hat{a}_{f}^{\dagger} \hat{a}_{g}^{\dagger} \hat{a}_{A}^{\dagger} \hat{a}_{I} \hat{a}_{o} \hat{a}_{n} \hat{a}_{m} \hat{a}_{l} \hat{a}_{k} \hat{a}_{j} \hat{a}_{i} \\&+ \frac{1}{512} \sum \limits_{a b c d e f g A B i j k l m n o I J} t^{a b c d e f g A B}_{i j k l m n o I J} \hat{a}_{a}^{\dagger} \hat{a}_{b}^{\dagger} \hat{a}_{c}^{\dagger} \hat{a}_{d}^{\dagger} \hat{a}_{e}^{\dagger} \hat{a}_{f}^{\dagger} \hat{a}_{g}^{\dagger} \hat{a}_{A}^{\dagger} \hat{a}_{B}^{\dagger} \hat{a}_{J} \hat{a}_{I} \hat{a}_{o} \hat{a}_{n} \hat{a}_{m} \hat{a}_{l} \hat{a}_{k} \hat{a}_{j} \hat{a}_{i} \\&+ \frac{1}{1024} \sum \limits_{a b c d e f g A B C i j k l m n o I J K} t^{a b c d e f g A B C}_{i j k l m n o I J K} \hat{a}_{a}^{\dagger} \hat{a}_{b}^{\dagger} \hat{a}_{c}^{\dagger} \hat{a}_{d}^{\dagger} \hat{a}_{e}^{\dagger} \hat{a}_{f}^{\dagger} \hat{a}_{g}^{\dagger} \hat{a}_{A}^{\dagger} \hat{a}_{B}^{\dagger} \hat{a}_{C}^{\dagger} \hat{a}_{K} \hat{a}_{J} \hat{a}_{I} \hat{a}_{o} \hat{a}_{n} \hat{a}_{m} \hat{a}_{l} \hat{a}_{k} \hat{a}_{j} \hat{a}_{i} \\&+ \cdots
\end{align*}

<p>
and we can try the same this time using
<code>lt-macrolet</code>
</p>

<div class="org-src-container">
<pre class="src src-listex">(cl-labels ((ps (n) (seq-take '(a b c d e f g A B C D E F G) n))
	    (hs (n) (seq-take '(i j k l m n o I J K L M N O) n)))

  (lt-macrolet* ((&amp;+ (&amp;rest args) `(%\\\\&amp;+ ,@args))
		 (t (up down) `(_ (^ t ,up) ,down))
		 (^a (i) `(_ (-hat a) ,i))
		 (^á (i) `(^ (^a ,i) /dagger))
		 ;; holes and particles
		 (áa (up down) `(,(cl-loop for p in up collect `(^á ,p))
				 ,(cl-loop for p in down collect `(^a ,p))))


		 (Σ (&amp;rest idx) `(_ (/sum /limits) ,@idx))

		 (τ (n) (let ((pow (math-power-of-2 n))
			      (abc (ps n))
			      (ijk (reverse (hs n))))
			  `(,(when (&gt; n 1) `(-frac 1 ,pow))
			    (Σ ,abc ,ijk)
			    (t ,abc ,ijk)
			    (áa ,abc ,ijk)))))

    '(%&amp;= (-hat T)
	  (&amp;+ (τ 1)
	      (τ 2)
	      (τ 3)))))

</pre>
</div>

\begin{align*}
\hat{T} &=  \sum \limits_{a i} t^{a}_{i} \hat{a}_{a}^{\dagger} \hat{a}_{i} \\&+ \frac{1}{4} \sum \limits_{a b j i} t^{a b}_{j i} \hat{a}_{a}^{\dagger} \hat{a}_{b}^{\dagger} \hat{a}_{j} \hat{a}_{i} \\&+ \frac{1}{8} \sum \limits_{a b c k j i} t^{a b c}_{k j i} \hat{a}_{a}^{\dagger} \hat{a}_{b}^{\dagger} \hat{a}_{c}^{\dagger} \hat{a}_{k} \hat{a}_{j} \hat{a}_{i}
\end{align*}
</div>
</div>
</div>



<div id="outline-container-org41a938b" class="outline-3">
<h3 id="org41a938b"><span class="section-number-3">10.2.</span> Latex document example</h3>
<div class="outline-text-3" id="text-10-2">
<p>
Even though <code>listex</code> is really thought for typesetting of formulas,
in principle writing documents in the style of
<a href="https://github.com/abo-abo/eltex">eltex</a> is roughly possible, but consider just using <code>org</code> for this.
Consider also reading <a href="https://oremacs.com/2015/01/23/eltex/">this blog post</a> if you really want to write
whole latex documents using s-expressions.
</p>

<div class="org-src-container">
<pre class="src src-listex">'(progn
   (-documentclass [12pt] article)
   (-usepackage hyperref)
   (env document
	(-section Introduction)
	(nl)
	(progn This document is is an example for the (-texttt LisTeX)
	       domain specific language \(DSL\).
	       (nl)

	       You can also do inline math

	       ($ (+ (^ A 5)) + 5)

	       or displaystyle math

	       (nl)

	       ($$ (+ (^ A 5) 5)
		   .)

	       )))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgd0f3722" class="outline-3">
<h3 id="orgd0f3722"><span class="section-number-3">10.3.</span> A matrix macro</h3>
<div class="outline-text-3" id="text-10-3">
<p>
This is a simple but useful macro defined in the macro section:
</p>

<div class="org-src-container">
<pre class="src src-listex">(lt-aliaslet ((φ '/phi)
	      († '/dagger))
  '(matrix 2 3
	 (-hat A) B (-dot E)
	 (-tilde (-hat C)) D (_ E (matrix 2 2
					  1 (* (-hat φ) †)
					  3 4))))
</pre>
</div>

<p>
\[\begin{pmatrix}
\hat{A} & B & \dot{E} \\ \tilde{\hat{C}} & D & E_{\begin{pmatrix}
1 & \hat{\phi} * \dagger \\ 3 & 4 \\
\end{pmatrix}} \\
\end{pmatrix}\]
</p>

<p>
And now imagine we want to find the \( D \)
and replace it with a \( \color{red}\psi \), well we can do it quite easily
since we defined a lisp reference for the above matrix called
<code>weird-matrix</code> and we can use the emacs lisp function <code>subst</code>
to find and replace in the sexp tree:
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">weird-matrix
</pre>
</div>


<div class="org-src-container">
<pre class="src src-listex">(cl-subst '(-color red /psi)
	  'D
	  weird-matrix)
</pre>
</div>

<p>
\[\begin{pmatrix}
\hat{A} & B & \dot{E} \\ \tilde{\hat{C}} & \color{red}{\psi} & E_{\begin{pmatrix}
1 & \hat{\phi} * \dagger \\ 3 & 4 \\
\end{pmatrix}} \\
\end{pmatrix}\]
</p>

<p>
That's not bad at all.
</p>
</div>
</div>


<div id="outline-container-orgd9d5533" class="outline-3">
<h3 id="orgd9d5533"><span class="section-number-3">10.4.</span> Cmdlet</h3>
<div class="outline-text-3" id="text-10-4">
<p>
There should be an easy way of defining lexically macros,
but I should think about tihs.
</p>

<p>
This is what works now, however the problem is that I would not want
to have to call <code>listex</code> before the command.
</p>

<div class="org-src-container">
<pre class="src src-listex">(lt-cmdlet ((χ (a b c) "%s^{%s^{%s}}"))
	   '(-frac (χ 5 5 5)
		   /varphi))

</pre>
</div>

<p>
\[\frac{5^{5^{5}}}{\varphi}\]
</p>
</div>
</div>

<div id="outline-container-orgdc22e3b" class="outline-3">
<h3 id="orgdc22e3b"><span class="section-number-3">10.5.</span> Schwarzschild's paper</h3>
<div class="outline-text-3" id="text-10-5">
<p>
This is a partial implementation of
<a href="https://de.wikisource.org/wiki/%C3%9Cber_das_Gravitationsfeld_eines_Massenpunktes_nach_der_Einsteinschen_Theorie">Schwarzschild's paper</a> as a testcase for a paper.
</p>

<div class="org-src-container">
<pre class="src src-listex">(lt-aliaslet ((δ '/delta)
	      (μ '/mu)
	      (ν '/nu)
	      (~% "\n")
	      (=nl= '\\\\)
	      (gμν '(_ g μ ν)))
  (lt-macrolet ((lisp (&amp;rest args) (eval `(progn ,@args)))
		(main (&amp;rest args) `(env document ,@args))
		(text (&amp;rest args) (progn (require 's)
					  (s-word-wrap 80 (listex args))))
		(code (&amp;rest args) `(-texttt ,@args))
		(* (&amp;rest title) `("\\section{" ,@title "}" "\n\n"))
		(** (&amp;rest title) `("\\subsection{" ,@title "}" "\n\n"))
		(*** (&amp;rest title) `("\\ssubsection{" ,@title "}" "\n\n"))
		(eqlab (label &amp;rest args) `(eq (-label ,label)
					       ,@args))

		(d! (var) `(progn (-mathrm d) ,var)))
    '(main
      (* Über das Gravitationsfeld eines Massenpunktes nach der
	 Einsteinschen Theorie.)

      (text Hr. Einstein hat in seiner Arbeit über die Perihelbewegung des
	    Merkur "(s. Sitzungsberichte vom 18. November 1915)" folgendes
	    Problem gestellt:

	    =nl=

	    Ein Punkt bewege sich gemäß der Forderung

	    (eqlab eq:main-metric-definition
		   (lr /{ \.
		       (env matrix
			    (= (δ /int (d! s))
			       0)
			    =nl= =nl=
			    (= (d! s)
			       (-sqrt (/sum gμν
					    (d! (_ x μ))
					    (d! (_ x ν))))))))

	    wobeit ($ gμν) Funktionen der Variabeln ($ x) bedeuten und bei
	    der Variation am Anfang und Ende des Integrationswegs die
	    Variablen ($ x) festzuhalten sind. Der Punkt
	    bewege sich "also," kurz "gesagt," auf einer geodätischen Linie in
	    der durch das Linienelement ($ (d! s)) charakterisierten
	    Mannigfaltigkeit.

	    =nl=

	    Die Ausführung der Variation ergibt die Bewegungsgleichungen des
	    Punktes)

      =nl=
      To be continued...)))

</pre>
</div>

\begin{document}
\section{ Über das Gravitationsfeld eines Massenpunktes nach der Einsteinschen Theorie. } 

 Hr. Einstein hat in seiner Arbeit über die Perihelbewegung des Merkur
(s. Sitzungsberichte vom 18. November 1915) folgendes Problem gestellt: \\ Ein
Punkt bewege sich gemäß der Forderung \begin{equation}
\label{eq:main-metric-definition} \left\{ \begin{matrix} \delta \int \mathrm{d}
s = 0 \\ \\ \mathrm{d} s = \sqrt{\sum g_{\mu \nu} \mathrm{d} x_{\mu} \mathrm{d}
x_{\nu}} \end{matrix} \right.  \end{equation} wobeit $g_{\mu \nu}$ Funktionen
der Variabeln $x$ bedeuten und bei der Variation am Anfang und Ende des
Integrationswegs die Variablen $x$ festzuhalten sind. Der Punkt bewege sich
also, kurz gesagt, auf einer geodätischen Linie in der durch das Linienelement
$\mathrm{d} s$ charakterisierten Mannigfaltigkeit. \\ Die Ausführung der
Variation ergibt die Bewegungsgleichungen des Punktes \\ To be continued...
\end{document}
</div>
</div>

<div id="outline-container-org155142e" class="outline-3">
<h3 id="org155142e"><span class="section-number-3">10.6.</span> XML renderer</h3>
<div class="outline-text-3" id="text-10-6">
<p>
Here is an example of how to extend what is implemented
in order to render XML easily.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">
(<span style="font-weight: bold;">defun</span> <span style="font-weight: bold;">listex:render-xml</span> (expr)
  <span style="font-style: italic;">"Main function to convert a listex DSL s-expression</span>
<span style="font-style: italic;">   into a latex-compatible string."</span>
  (<span style="font-weight: bold;">cl-etypecase</span> expr
    (listex:lisp-macro (<span style="font-weight: bold;">let*</span> ((args (cdr expr))
                              (name (car expr))
                              (f (listex:lisp-macro-get-fun name))
                              (new-expr (apply f args)))
                         (listex:render-xml new-expr)))
    (listex:alias (<span style="font-weight: bold;">let*</span> ((replacement (listex:get-alias expr)))
                    (listex:render-xml replacement)))
    (listex:command
     (<span style="font-weight: bold;">let*</span> ((name (string-remove-prefix
                   listex-command-prefix
                   (symbol-name (car expr))))
            (args-strings (mapcar #'listex:render-xml (cdr expr))))
       (format <span style="font-style: italic;">"%s=\"%s\""</span> name (string-join args-strings <span style="font-style: italic;">" "</span>))))
    (list (string-join (mapcar #'listex:render-xml expr) <span style="font-style: italic;">" "</span>))
    (atom (format <span style="font-style: italic;">"%s"</span> expr))))


(<span style="font-weight: bold;">defmacro</span> <span style="font-weight: bold;">with-xml</span> (<span style="font-weight: bold; text-decoration: underline;">&amp;rest</span> body)
  `(<span style="font-weight: bold;">cl-flet</span> ((commandp (<span style="font-weight: bold;">lambda</span> (e) (typep e 'listex:command)))
             (join-exprs (l) (string-join (mapcar #'listex:render-xml l) <span style="font-style: italic;">" "</span>)))
       (lt-macrolet ((&gt; (name <span style="font-weight: bold; text-decoration: underline;">&amp;rest</span> content)
                        (<span style="font-weight: bold;">let</span> ((commands (remove-if-not #'commandp content))
                              (tag-content (remove-if #'commandp content)))
                          (format <span style="font-style: italic;">"&lt;%s %s&gt;\n%s\n&lt;/%1$s&gt;\n"</span>
                                  name
                                  (join-exprs commands)
                                  (join-exprs tag-content)))))
         ,@body)))
</pre>
</div>

<p>
and we can use it in a minimal example that still is neat.
</p>

<div class="org-src-container">
<pre class="src src-listex">(lt-macrolet ((π (&amp;rest body) `(&gt; p (-class md-3 flex) ,@body)))
  (with-xml
   '(&gt; html
       (&gt; head
	  (&gt; title
	     This is the inside of this title))
       (&gt; body
	  (&gt; div (-class "content")
	     (π Here is a paragraph of my blog.
		I am pretty happy about how my paragraph is coming along.)

	     And this is some content that I want to put
	     outside of my paragraph.)))))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-html">&lt;<span style="font-weight: bold;">html</span> &gt;
&lt;<span style="font-weight: bold;">head</span> &gt;
&lt;<span style="font-weight: bold;">title</span> &gt;
<span style="font-weight: bold; text-decoration: underline;">This is the inside of this title</span>
&lt;/<span style="font-weight: bold;">title</span>&gt;

&lt;/<span style="font-weight: bold;">head</span>&gt;
 &lt;<span style="font-weight: bold;">body</span> &gt;
&lt;<span style="font-weight: bold;">div</span> <span style="font-weight: bold; font-style: italic;">class</span>=<span style="font-style: italic;">"content"</span>&gt;
&lt;<span style="font-weight: bold;">p</span> <span style="font-weight: bold; font-style: italic;">class</span>=<span style="font-style: italic;">"md-3 flex"</span>&gt;
Here is a paragraph of my blog. I am pretty happy about how my paragraph is coming along.
&lt;/<span style="font-weight: bold;">p</span>&gt;
 And this is some content that I want to put outside of my paragraph.
&lt;/<span style="font-weight: bold;">div</span>&gt;

&lt;/<span style="font-weight: bold;">body</span>&gt;

&lt;/<span style="font-weight: bold;">html</span>&gt;
</pre>
</div>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Alejandro Gallo</p>
<p class="date">Created: 2022-03-29 Tue 21:01</p>
<p class="validation"><a href="https://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
